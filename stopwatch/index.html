<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Online Stopwatch & Countdown Timer | Tools Pack</title>
    <meta
      name="description"
      content="Precise stopwatch and countdown with pause/reset and alarm beep."
    />
    <link rel="canonical" href="https://tools-pack.netlify.app/stopwatch/" />
    <link rel="stylesheet" href="../assets/style.css" />
    <meta name="theme-color" content="#1E1E2F" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Stopwatch & Countdown — Tools Pack" />
    <meta
      property="og:description"
      content="Start, pause, reset; set countdown."
    />
    <meta
      property="og:url"
      content="https://tools-pack.netlify.app/stopwatch/"
    />
    <meta
      property="og:image"
      content="https://tools-pack.netlify.app/og/time.png"
    />
    <meta name="twitter:card" content="summary_large_image" />
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Stopwatch & Countdown",
        "url": "https://tools-pack.netlify.app/stopwatch/",
        "applicationCategory": "Utility",
        "operatingSystem": "All",
        "description": "Accurate stopwatch and countdown.",
        "inLanguage": "en"
      }
    </script>
  </head>
  <body>
    <header class="sticky">
      <div class="wrap brand">
        <a href="/"><div class="logo"></div></a>
        <div>
          <h1 style="margin: 0">Stopwatch & Countdown</h1>
          <div class="sub">Precise timing</div>
        </div>
      </div>
    </header>

    <main class="wrap">
      <article class="card">
        <div
          id="swDisp"
          class="field center"
          style="font-size: 28px; font-weight: 700"
          aria-live="polite"
        >
          00:00.000
        </div>
        <div>
          <button class="btn btn-primary" id="swStart" type="button">
            Start
          </button>
          <button class="btn" id="swPause" type="button">Pause</button>
          <button class="btn" id="swReset" type="button">Reset</button>
        </div>

        <hr style="border: none; border-top: var(--border)" />

        <div class="row">
          <input
            id="m"
            class="field"
            type="number"
            min="0"
            value="0"
            placeholder="Minutes"
            inputmode="numeric"
          />
          <input
            id="s"
            class="field"
            type="number"
            min="0"
            max="59"
            value="30"
            placeholder="Seconds"
            inputmode="numeric"
          />
        </div>
        <div>
          <button class="btn" id="cdStart" type="button">
            Start Countdown
          </button>
          <button class="btn" id="cdStop" type="button">Stop</button>
        </div>
        <div id="cdDisp" class="field center" aria-live="polite">00:30</div>
      </article>
    </main>

    <footer>© <span id="y"></span> Tools Pack</footer>

    <script>
      // Shorthand
      const $ = (id) => document.getElementById(id);

      // Elements (no implicit globals)
      const yearEl = $("y");
      const swDisp = $("swDisp");
      const swStart = $("swStart");
      const swPause = $("swPause");
      const swReset = $("swReset");
      const minEl = $("m");
      const secEl = $("s");
      const cdStart = $("cdStart");
      const cdStop = $("cdStop");
      const cdDisp = $("cdDisp");

      yearEl.textContent = new Date().getFullYear();

      // ---------- Stopwatch ----------
      let swRAF = null;
      let swStartTS = 0; // performance.now() at (re)start
      let swElapsed = 0; // accumulated ms while paused/running

      const fmtMS = (ms) => {
        const m = Math.floor(ms / 60000);
        const s = Math.floor((ms % 60000) / 1000);
        const x = Math.floor(ms % 1000);
        return `${String(m).padStart(2, "0")}:${String(s).padStart(
          2,
          "0"
        )}.${String(x).padStart(3, "0")}`;
      };

      const swTick = () => {
        const now = performance.now();
        swDisp.textContent = fmtMS(swElapsed + (now - swStartTS));
        swRAF = requestAnimationFrame(swTick);
      };

      swStart.onclick = () => {
        unlockAudio(); // prime audio on user gesture
        if (swRAF) return; // already running
        swStartTS = performance.now();
        swRAF = requestAnimationFrame(swTick);
      };

      swPause.onclick = () => {
        if (!swRAF) return;
        cancelAnimationFrame(swRAF);
        swRAF = null;
        swElapsed += performance.now() - swStartTS;
        swDisp.textContent = fmtMS(swElapsed);
      };

      swReset.onclick = () => {
        if (swRAF) cancelAnimationFrame(swRAF);
        swRAF = null;
        swElapsed = 0;
        swDisp.textContent = "00:00.000";
      };

      // ---------- Countdown (drift-free) ----------
      let cdTimer = null;
      let cdEndAt = 0; // epoch ms when countdown ends

      const fmtS = (t) => {
        const mm = String(Math.floor(t / 60)).padStart(2, "0");
        const ss = String(Math.max(0, Math.floor(t % 60))).padStart(2, "0");
        return `${mm}:${ss}`;
      };

      // Single shared AudioContext (safer for autoplay policies)
      let ac = null;
      function unlockAudio() {
        const Ctx = window.AudioContext || window.webkitAudioContext;
        if (!Ctx) return;
        if (!ac) ac = new Ctx();
        if (ac.state === "suspended") {
          // resume on user gesture
          ac.resume().catch(() => {});
        }
      }

      function beep() {
        if (!ac) return; // if no context, just skip beep
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.type = "sine";
        o.frequency.value = 880;
        o.connect(g);
        g.connect(ac.destination);
        const t0 = ac.currentTime;
        g.gain.setValueAtTime(0.0001, t0);
        g.gain.exponentialRampToValueAtTime(0.2, t0 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.6);
        o.start(t0);
        o.stop(t0 + 0.65);
      }

      const cdUpdate = () => {
        const now = Date.now();
        const secondsLeft = Math.max(0, Math.ceil((cdEndAt - now) / 1000));
        cdDisp.textContent = fmtS(secondsLeft);
        if (secondsLeft <= 0) {
          clearInterval(cdTimer);
          cdTimer = null;
          beep();
        }
      };

      // Keep display in sync with inputs
      const reflectInputs = () => {
        const M = Math.max(0, parseInt(minEl.value || "0", 10));
        let S = Math.max(0, parseInt(secEl.value || "0", 10));
        if (S > 59) S = 59;
        secEl.value = String(S);
        cdDisp.textContent = fmtS(M * 60 + S);
      };
      minEl.addEventListener("input", reflectInputs);
      secEl.addEventListener("input", reflectInputs);
      reflectInputs();

      cdStart.onclick = () => {
        unlockAudio(); // user gesture -> unlock
        const M = Math.max(0, parseInt(minEl.value || "0", 10));
        const S = Math.max(0, Math.min(59, parseInt(secEl.value || "0", 10)));
        const total = M * 60 + S;
        if (total <= 0) return;

        if (cdTimer) clearInterval(cdTimer);
        // Add a tiny bias so first tick doesn't immediately drop a second
        cdEndAt = Date.now() + total * 1000 + 50;
        cdUpdate();
        // Update at 250 ms for snappier UI but low CPU
        cdTimer = setInterval(cdUpdate, 250);
      };

      cdStop.onclick = () => {
        if (cdTimer) clearInterval(cdTimer);
        cdTimer = null;
      };

      // Also unlock audio on the very first interaction anywhere
      window.addEventListener("pointerdown", unlockAudio, { once: true });
    </script>
  </body>
</html>
